Simon Peter Campbell (N3053620)
-------------------------------
Milestone 3 v1 (21/11/2014)
--------------------------------

New Functionality
-----------------

Blit supports clipping
Controller support
Controller rumble support
Textures that are off-screen are skipped completely

Code Additions
--------------

Rectangle class             A left-top-right-bottom Rectangle class used for clipping images before blitting.
Game class                  Basic encapsulation for the entire game loop.
Game::updateCapped          Obtains controller input and handles controller vibration.
ScreenManager::blit         An entry point for all blitting functions.
BlendType enum              Determines what blending model to use for the blitting.

Tests
-----

Load a texture which is slightly off-screen:       The texture will be clipped appropriately.
Plug in a controller after starting the game:      The controller is found and input is enabled.
Move the left analogue stick on a controller:      Moves the object on-screen.
Unplug a controller after starting the game:       Controller input is disabled and doesn't effect frame-rate.


(e.g. a stress test may be done where you try extreme values for things. e.g. render 1,000 sprites all at the same time)

Notes
-----

Most of the milestone was just cleanup work, there wasn't much core functionality that needed to be added to support clipping


Milestone 2 v1 (24/10/2014)
--------------------------------

New Functionality
-----------------

Can load textures
Can blit textures using a very fast opaque algorithm, a fast blending algorithm or a slow blending algorithm
A texture can be blended into another texture using alpha values
The blended texture can be used using keyboard input
Textures which are slightly off-screen are not rendered

Code Additions
--------------

ScreenManager::blitOpaque   Blits a texture to the screen line-by-line for efficiency, disregarding alpha values.
ScreenManager::blitFast     Blits a texture to the screen by accessing the raw texture data and using bit-shifting for alpha blending.
Texture class               Encapsulates a HAPI loaded texture, ensuring the avoidance of memory leaks. Can return a read-only version of 
                            the stored data.
HAPI_Main()                 Handles keyboard input and the rendering order of the textures.

Tests
-----

Load a texture which doesn't exist:       The program will exit cleanly after informing the user of a missing texture.
Try to draw a texture off-screen:         The texture is ignored and not drawn at all.
Try to move the blended image off-screen: The user cannot move any further than the screen boundaries.


(e.g. a stress test may be done where you try extreme values for things. e.g. render 1,000 sprites all at the same time)

Notes
-----

Initially I tried using getPixel functions to obtain the data from the Texture class but that was incredibly slow. To remedy this whilst
maintaining the ownership of the data with the Texture class I just returned a const pointer to const data to ensure it was read-only.
My application is about 5% slower than the example which is a margin I am happy with for now but I look to increase efficiency in later
milestones.


Milestone 1 v1 (21/10/2014)
--------------------------------

New Functionality
-----------------

The screen can be cleared to an abritrary colour.
Render randomly coloured and randomly positioned stars onto the screen which move forward at a random speed, creating a 3D movement effect.

Code Additions
--------------

Vector3D struct         Contains the 3D position of each Star and is used in simulating velocity.
Pixel struct            Contains the X and Y co-ordinates of a pixel and the colour it should be on the screen.
Star class              Contains a position and velocity, it uses them to produce the 3D moving star effect in 2D.
ScreenManager class     Provides an easy way of managing what is displayed on the screen.
RNG template            Encapsulates a C++11 uniform distribution and a default random engine for all integer and floating-point data types.
HAPI_Main()             The entry point of the application.

Tests
-----

Providing an invalid Z position to create a divide by zero error:     This case is handled by dividing by 0.001f instead.
Creating over one million stars:                                      The frame rate is effected but no crashing occurs.
Creating an RNG with a min value which is larger than max:            This case is handled by swapping the values.


(e.g. a stress test may be done where you try extreme values for things. e.g. render 1,000 sprites all at the same time)

Notes
-----

I created a lot of extra classes and functionality which weren't needed for the milestone but I done it for the sake of future usage and
because it allowed me to get used to C++ again after four months of using C# instead. My code could also be faster because I have a lot of
error checking in case I do something stupid with the code, as a result I should insert more logging when I avoid errors.

